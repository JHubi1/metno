import 'dart:async';
import 'dart:convert';

import 'package:http/http.dart' as http;

import 'constants/pubspec.yaml.g.dart';
import 'classes.dart';

Map _weatherApiError = {
  204: "No Content",
  400: "Bad Request",
  401: "Unauthorized",
  403: "Forbidden",
  404: "Not Found",
  422: "Unprocessable Entity",
  429: "Too Many Requests",
  500: "Internal Server Error",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout"
};

/// An error occurred while fetching or parsing weather data.
///
/// This exception is only thrown from the [Weather.fetch] and [Weather.parse]
/// method.
class WeatherException implements Exception {
  final dynamic message;
  WeatherException([this.message]);

  /// Creates a new string representation of this object.
  @override
  String toString() {
    Object? message = this.message;
    if (message == null) return "Unknown exception";
    return "$message";
  }
}

/// The main [Weather] class.
///
/// This class is used to fetch and parse weather data from the met.no API.
/// The data always contains the keys [type], [geometry] and [properties].
class Weather {
  /// The type of the weather data.
  final WeatherType type;

  /// The position of the collected weather data.
  final WeatherGeometry geometry;

  /// Properties, like meta and timeseries.
  final WeatherProperties properties;

  /// Parses a weather data map into a weather object.
  ///
  /// The [data] parameter must be a valid map generated by the met.no API.
  /// Alternatively, this function can also parse maps generated by the [toMap]
  /// method.
  ///
  /// The [WeatherException] is thrown if the weather type or geometry type is
  /// unknown. See error message for more information.
  Weather.parse(Map<String, dynamic> data)
      : type = (data["type"] == "Feature")
            ? WeatherType.feature
            : throw WeatherException(
                "Unknown weather type, ${data["type"]}. Report an issue at: https://github.com/JHubi1/metno/issues"),
        geometry = WeatherGeometry(
            type: (data["geometry"]["type"] == "Point")
                ? WeatherGeometryType.point
                : throw WeatherException(
                    "Unknown geometry type, ${data["geometry"]["type"]}. Report an issue at: https://github.com/JHubi1/metno/issues"),
            coordinates: (data["geometry"]["coordinates"] as List)
                .map((e) => e as num)
                .toList()),
        properties = WeatherProperties(
            meta: WeatherMeta(
                updatedAt:
                    DateTime.parse(data["properties"]["meta"]["updated_at"]),
                units:
                    WeatherUnits.fromMap(data["properties"]["meta"]["units"])),
            timeseries: List<WeatherSlot>.from(
                (data["properties"]["timeseries"] as List)
                    .map((x) => WeatherSlot.fromMap(x))));

  /// Fetches and loads weather data from the met.no API.
  ///
  /// The [latitude] and [longitude] parameters are required and must be valid.
  /// The [altitude] parameter is optional and can be used to specify the
  /// altitude of the location.
  ///
  /// The [WeatherException] is thrown if the request fails or the response
  /// status code is not 200. See error message for more information.
  static Future<Weather> fetch(
      {required num latitude,
      required num longitude,
      num? altitude,
      String? userAgent}) async {
    var uri =
        "https://api.met.no/weatherapi/locationforecast/2.0/complete?lat=${Uri.encodeComponent(latitude.toString())}&lon=${Uri.encodeComponent(longitude.toString())}";
    if (altitude != null) {
      uri += "&altitude=${Uri.encodeComponent(altitude.toString())}";
    }

    http.Response response;
    try {
      response = await http.get(Uri.parse(uri), headers: {
        "Accept": "application/json",
        "User-Agent": userAgent ??
            "metno/${Pubspec.version.major}.${Pubspec.version.minor} (https://pub.dev/packages/metno)"
      });
    } catch (e) {
      throw WeatherException("Failed to fetch weather data; $e");
    }

    if (response.statusCode != 200) {
      String message;
      if (_weatherApiError.containsKey(response.statusCode)) {
        message = _weatherApiError[response.statusCode];
      } else {
        message = "Unknown error";
      }
      throw WeatherException("Failed to fetch weather data: $message");
    }

    return Weather.parse(jsonDecode(response.body));
  }

  /// Refreshes the weather data.
  Future<Weather> refresh() async {
    return fetch(
        latitude: geometry.coordinates[1],
        longitude: geometry.coordinates[0],
        altitude: geometry.coordinates[2]);
  }

  /// Creates a new map representation of this object.
  Map<String, dynamic> toMap() {
    return {
      "type": type.toString().split(".").last.toTitleCase(),
      "geometry": geometry.toMap(),
      "properties": properties.toMap()
    };
  }

  /// Creates a new string representation of this object.
  @override
  String toString() {
    return jsonEncode(toMap());
  }

  @override
  bool operator ==(Object other) {
    return other is Weather && other.toString() == toString();
  }

  @override
  int get hashCode => toMap().hashCode;
}
